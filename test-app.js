#!/usr/bin/env node
/**
 * @file test-app.js
 * @description Automated testing suite for XML Editor Desktop
 * @version 1.0.0
 * @date 2025-10-02
 */

const sqlite3 = require('sqlite3').verbose();
const fs = require('fs-extra');
const path = require('path');

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  DB_PATH: path.join(__dirname, 'xmleditor.db'),
  SCHEMAS_PATH: path.join(__dirname, 'src/schemas'),
  TEST_OUTPUT: path.join(__dirname, 'TEST_RESULTS.md'),
  EXPORT_PATH: path.join(__dirname, 'test-exports'),
  SCHEMA_VERSIONS: ['01.03', '01.04', '01.05']
};

// ============================================================================
// TEST RESULTS TRACKER
// ============================================================================

class TestTracker {
  constructor() {
    this.tests = [];
    this.startTime = Date.now();
  }

  addTest(category, name, status, duration, details = '') {
    this.tests.push({
      category,
      name,
      status, // 'pass' | 'fail' | 'skip'
      duration,
      details
    });
  }

  getStats() {
    const total = this.tests.length;
    const passed = this.tests.filter(t => t.status === 'pass').length;
    const failed = this.tests.filter(t => t.status === 'fail').length;
    const skipped = this.tests.filter(t => t.status === 'skip').length;
    const successRate = total > 0 ? ((passed / total) * 100).toFixed(2) : 0;
    const totalDuration = Date.now() - this.startTime;

    return { total, passed, failed, skipped, successRate, totalDuration };
  }

  generateReport() {
    const stats = this.getStats();
    const timestamp = new Date().toISOString();

    let report = '';
    report += '# XML Editor Desktop - Automated Test Report\n\n';
    report += `**Generated:** ${timestamp}\n`;
    report += `**Duration:** ${stats.totalDuration}ms\n\n`;
    report += '---\n\n';

    report += '## Summary\n\n';
    report += `| Metric | Value |\n`;
    report += `|--------|-------|\n`;
    report += `| Total Tests | ${stats.total} |\n`;
    report += `| Passed | ${stats.passed} âœ… |\n`;
    report += `| Failed | ${stats.failed} âŒ |\n`;
    report += `| Skipped | ${stats.skipped} â­ï¸ |\n`;
    report += `| Success Rate | ${stats.successRate}% |\n\n`;

    // Group tests by category
    const categories = {};
    this.tests.forEach(test => {
      if (!categories[test.category]) {
        categories[test.category] = [];
      }
      categories[test.category].push(test);
    });

    report += '## Detailed Results\n\n';

    Object.entries(categories).forEach(([category, tests]) => {
      const categoryPassed = tests.filter(t => t.status === 'pass').length;
      const categoryTotal = tests.length;

      report += `### ${category} (${categoryPassed}/${categoryTotal})\n\n`;

      tests.forEach(test => {
        const icon = test.status === 'pass' ? 'âœ…' :
                     test.status === 'fail' ? 'âŒ' : 'â­ï¸';
        report += `${icon} **${test.name}** (${test.duration}ms)\n`;
        if (test.details) {
          report += `   - ${test.details}\n`;
        }
        report += '\n';
      });
    });

    report += '---\n\n';
    report += `**Report generated by XML Editor Desktop Test Suite v1.0.0**\n`;

    return report;
  }

  printConsoleReport() {
    const stats = this.getStats();

    console.log('\n');
    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘        AUTOMATED TESTS REPORT                              â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log('');

    // Group by category
    const categories = {};
    this.tests.forEach(test => {
      if (!categories[test.category]) categories[test.category] = [];
      categories[test.category].push(test);
    });

    Object.entries(categories).forEach(([category, tests]) => {
      const passed = tests.filter(t => t.status === 'pass').length;
      const total = tests.length;
      const icon = passed === total ? 'âœ…' : 'âš ï¸';
      console.log(`ðŸ“Š ${category}: ${passed}/${total} ${icon}`);
    });

    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
    console.log(`TOTAL:                      ${stats.passed}/${stats.total} ${stats.passed === stats.total ? 'âœ…' : 'âš ï¸'}`);
    console.log(`SUCCESS RATE:                 ${stats.successRate}%`);
    console.log(`DURATION:                     ${stats.totalDuration}ms`);
    console.log('');

    if (stats.passed === stats.total) {
      console.log('ðŸŽ‰ ALL TESTS PASSED!');
    } else {
      console.log(`âš ï¸  ${stats.failed} TEST(S) FAILED`);
    }
    console.log('');
  }
}

// ============================================================================
// DATABASE HELPER
// ============================================================================

class DatabaseHelper {
  constructor(dbPath) {
    this.dbPath = dbPath;
    this.db = null;
  }

  open() {
    return new Promise((resolve, reject) => {
      this.db = new sqlite3.Database(this.dbPath, (err) => {
        if (err) reject(err);
        else resolve();
      });
    });
  }

  close() {
    return new Promise((resolve, reject) => {
      if (this.db) {
        this.db.close((err) => {
          if (err) reject(err);
          else resolve();
        });
      } else {
        resolve();
      }
    });
  }

  run(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.db.run(sql, params, function(err) {
        if (err) reject(err);
        else resolve({ lastID: this.lastID, changes: this.changes });
      });
    });
  }

  get(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.db.get(sql, params, (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });
  }

  all(sql, params = []) {
    return new Promise((resolve, reject) => {
      this.db.all(sql, params, (err, rows) => {
        if (err) reject(err);
        else resolve(rows);
      });
    });
  }
}

// ============================================================================
// TEST SUITES
// ============================================================================

class TestSuite {
  constructor(tracker) {
    this.tracker = tracker;
  }

  async runTest(category, name, testFn) {
    const start = Date.now();
    try {
      const details = await testFn();
      const duration = Date.now() - start;
      this.tracker.addTest(category, name, 'pass', duration, details);
      console.log(`âœ… ${name} (${duration}ms)`);
      return true;
    } catch (error) {
      const duration = Date.now() - start;
      this.tracker.addTest(category, name, 'fail', duration, error.message);
      console.log(`âŒ ${name} (${duration}ms)`);
      console.log(`   Error: ${error.message}`);
      return false;
    }
  }
}

// ============================================================================
// DATABASE TESTS
// ============================================================================

class DatabaseTests extends TestSuite {
  constructor(tracker, db) {
    super(tracker);
    this.db = db;
  }

  async runAll() {
    console.log('\nðŸ—„ï¸  DATABASE TESTS');
    console.log('â•'.repeat(60));

    await this.runTest('Database', 'Database file exists', async () => {
      const exists = await fs.pathExists(CONFIG.DB_PATH);
      if (!exists) throw new Error('Database file not found');
      return `Path: ${CONFIG.DB_PATH}`;
    });

    await this.runTest('Database', 'Database connection', async () => {
      await this.db.open();
      return 'Connection successful';
    });

    await this.runTest('Database', 'Table: documents', async () => {
      const table = await this.db.get(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='documents'"
      );
      if (!table) throw new Error('Table "documents" not found');
      return 'Table exists';
    });

    await this.runTest('Database', 'Table: autosaves', async () => {
      const table = await this.db.get(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='autosaves'"
      );
      if (!table) throw new Error('Table "autosaves" not found');
      return 'Table exists';
    });

    await this.runTest('Database', 'Table: settings', async () => {
      const table = await this.db.get(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='settings'"
      );
      if (!table) throw new Error('Table "settings" not found');
      return 'Table exists';
    });

    await this.runTest('Database', 'Table: templates', async () => {
      const table = await this.db.get(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='templates'"
      );
      if (!table) throw new Error('Table "templates" not found');
      return 'Table exists';
    });

    await this.runTest('Database', 'Table: document_history', async () => {
      const table = await this.db.get(
        "SELECT name FROM sqlite_master WHERE type='table' AND name='document_history'"
      );
      if (!table) throw new Error('Table "document_history" not found');
      return 'Table exists';
    });
  }
}

// ============================================================================
// SCHEMA TESTS
// ============================================================================

class SchemaTests extends TestSuite {
  async runAll() {
    console.log('\nðŸ“‹ SCHEMA TESTS');
    console.log('â•'.repeat(60));

    for (const version of CONFIG.SCHEMA_VERSIONS) {
      await this.runTest('Schemas', `JSON Schema ${version} exists`, async () => {
        const schemaPath = path.join(CONFIG.SCHEMAS_PATH, 'json', `pz-${version}-schema.json`);
        const exists = await fs.pathExists(schemaPath);
        if (!exists) throw new Error(`Schema file not found: ${schemaPath}`);
        return `Path: ${schemaPath}`;
      });

      await this.runTest('Schemas', `JSON Schema ${version} is valid`, async () => {
        const schemaPath = path.join(CONFIG.SCHEMAS_PATH, 'json', `pz-${version}-schema.json`);
        const content = await fs.readFile(schemaPath, 'utf8');
        const schema = JSON.parse(content);
        if (!schema.$schema) throw new Error('Missing $schema property');
        return `Properties: ${Object.keys(schema).length}`;
      });

      await this.runTest('Schemas', `Mapping ${version} exists`, async () => {
        const mappingPath = path.join(CONFIG.SCHEMAS_PATH, 'mappings', `explanatory-note-${version}-mapping.json`);
        const exists = await fs.pathExists(mappingPath);
        if (!exists) throw new Error(`Mapping file not found: ${mappingPath}`);
        return `Path: ${mappingPath}`;
      });

      await this.runTest('Schemas', `Mapping ${version} is valid`, async () => {
        const mappingPath = path.join(CONFIG.SCHEMAS_PATH, 'mappings', `explanatory-note-${version}-mapping.json`);
        const content = await fs.readFile(mappingPath, 'utf8');
        const mapping = JSON.parse(content);
        if (!mapping.mappings) throw new Error('Missing mappings property');
        return `Mappings: ${Object.keys(mapping.mappings).length}`;
      });
    }
  }
}

// ============================================================================
// CRUD TESTS
// ============================================================================

class CRUDTests extends TestSuite {
  constructor(tracker, db) {
    super(tracker);
    this.db = db;
    this.testDocumentId = null;
    this.testTemplateId = null;
  }

  async runAll() {
    console.log('\nðŸ“ CRUD TESTS');
    console.log('â•'.repeat(60));

    // Document CRUD
    await this.runTest('CRUD', 'Create document', async () => {
      const result = await this.db.run(
        `INSERT INTO documents (title, schema_version, content, created_at, updated_at)
         VALUES (?, ?, ?, ?, ?)`,
        ['Test Document', '01.05', JSON.stringify({ test: true }),
         new Date().toISOString(), new Date().toISOString()]
      );
      this.testDocumentId = result.lastID;
      return `Document ID: ${this.testDocumentId}`;
    });

    await this.runTest('CRUD', 'Read document', async () => {
      const doc = await this.db.get(
        'SELECT * FROM documents WHERE id = ?',
        [this.testDocumentId]
      );
      if (!doc) throw new Error('Document not found');
      if (doc.title !== 'Test Document') throw new Error('Invalid title');
      return `Title: ${doc.title}`;
    });

    await this.runTest('CRUD', 'Update document', async () => {
      await this.db.run(
        'UPDATE documents SET title = ?, updated_at = ? WHERE id = ?',
        ['Updated Test Document', new Date().toISOString(), this.testDocumentId]
      );
      const doc = await this.db.get(
        'SELECT * FROM documents WHERE id = ?',
        [this.testDocumentId]
      );
      if (doc.title !== 'Updated Test Document') throw new Error('Update failed');
      return 'Update successful';
    });

    await this.runTest('CRUD', 'List documents', async () => {
      const docs = await this.db.all('SELECT * FROM documents');
      return `Found ${docs.length} document(s)`;
    });

    // Template CRUD
    await this.runTest('CRUD', 'Create template', async () => {
      const result = await this.db.run(
        `INSERT INTO templates (name, description, schema_version, content, created_at)
         VALUES (?, ?, ?, ?, ?)`,
        ['Test Template', 'Test Description', '01.05',
         JSON.stringify({ test: true }), new Date().toISOString()]
      );
      this.testTemplateId = result.lastID;
      return `Template ID: ${this.testTemplateId}`;
    });

    await this.runTest('CRUD', 'Read template', async () => {
      const template = await this.db.get(
        'SELECT * FROM templates WHERE id = ?',
        [this.testTemplateId]
      );
      if (!template) throw new Error('Template not found');
      return `Name: ${template.name}`;
    });

    // Autosave
    await this.runTest('CRUD', 'Create autosave', async () => {
      const result = await this.db.run(
        `INSERT INTO autosaves (document_id, content, created_at)
         VALUES (?, ?, ?)`,
        [this.testDocumentId, JSON.stringify({ autosave: true }),
         new Date().toISOString()]
      );
      return `Autosave ID: ${result.lastID}`;
    });

    // Settings
    await this.runTest('CRUD', 'Set setting', async () => {
      await this.db.run(
        `INSERT OR REPLACE INTO settings (key, value, updated_at)
         VALUES (?, ?, ?)`,
        ['test_setting', 'test_value', new Date().toISOString()]
      );
      return 'Setting created';
    });

    await this.runTest('CRUD', 'Get setting', async () => {
      const setting = await this.db.get(
        'SELECT * FROM settings WHERE key = ?',
        ['test_setting']
      );
      if (!setting || setting.value !== 'test_value') {
        throw new Error('Setting not found or invalid');
      }
      return `Value: ${setting.value}`;
    });
  }

  async cleanup() {
    console.log('\nðŸ§¹ CLEANUP');
    console.log('â•'.repeat(60));

    await this.runTest('Cleanup', 'Delete test document', async () => {
      if (this.testDocumentId) {
        await this.db.run('DELETE FROM documents WHERE id = ?', [this.testDocumentId]);
        return 'Document deleted';
      }
      return 'No document to delete';
    });

    await this.runTest('Cleanup', 'Delete test template', async () => {
      if (this.testTemplateId) {
        await this.db.run('DELETE FROM templates WHERE id = ?', [this.testTemplateId]);
        return 'Template deleted';
      }
      return 'No template to delete';
    });

    await this.runTest('Cleanup', 'Delete test setting', async () => {
      await this.db.run('DELETE FROM settings WHERE key = ?', ['test_setting']);
      return 'Setting deleted';
    });
  }
}

// ============================================================================
// XML GENERATION TESTS
// ============================================================================

class XMLGenerationTests extends TestSuite {
  async runAll() {
    console.log('\nðŸ—ï¸  XML GENERATION TESTS');
    console.log('â•'.repeat(60));

    await this.runTest('XML Generation', 'XMLGenerator module exists', async () => {
      const generatorPath = path.join(__dirname, 'src/renderer/js/xml-generator.js');
      const exists = await fs.pathExists(generatorPath);
      if (!exists) throw new Error('XMLGenerator not found');
      return `Path: ${generatorPath}`;
    });

    await this.runTest('XML Generation', 'Generate minimal XML 01.05', async () => {
      const testData = {
        generalInfo: {
          documentNumber: 'TEST-001',
          documentDate: '2025-10-02',
          projectName: 'Test Project'
        },
        objectInfo: {
          objectType: 'Residential'
        },
        contractor: {
          name: 'Test Contractor LLC'
        },
        designer: {
          name: 'Test Designer LLC'
        }
      };

      const xml = this.generateTestXML(testData, '01.05');
      if (!xml.includes('<?xml version="1.0"')) {
        throw new Error('Invalid XML declaration');
      }
      if (!xml.includes('<ExplanatoryNote')) {
        throw new Error('Missing root element');
      }

      // Save to file
      await fs.ensureDir(CONFIG.EXPORT_PATH);
      const outputPath = path.join(CONFIG.EXPORT_PATH, 'test-01.05.xml');
      await fs.writeFile(outputPath, xml, 'utf8');

      return `XML generated (${xml.length} bytes)`;
    });

    await this.runTest('XML Generation', 'Verify XML file created', async () => {
      const outputPath = path.join(CONFIG.EXPORT_PATH, 'test-01.05.xml');
      const exists = await fs.pathExists(outputPath);
      if (!exists) throw new Error('XML file not created');
      const content = await fs.readFile(outputPath, 'utf8');
      return `File size: ${content.length} bytes`;
    });

    await this.runTest('XML Generation', 'XML namespace check', async () => {
      const outputPath = path.join(CONFIG.EXPORT_PATH, 'test-01.05.xml');
      const content = await fs.readFile(outputPath, 'utf8');
      if (!content.includes('xmlns="http://minstroyrf.gov.ru/schemas/explanatorynote/01.05"')) {
        throw new Error('Invalid or missing namespace');
      }
      return 'Namespace valid';
    });
  }

  generateTestXML(data, version) {
    const namespace = `http://minstroyrf.gov.ru/schemas/explanatorynote/${version}`;
    const xmlHeader = '<?xml version="1.0" encoding="UTF-8"?>';
    const rootStart = `<ExplanatoryNote xmlns="${namespace}" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" Version="${version}">`;
    const rootEnd = '</ExplanatoryNote>';

    let content = '  <GeneralInfo>\n';
    content += `    <DocNumber>${data.generalInfo.documentNumber}</DocNumber>\n`;
    content += `    <DocDate>${data.generalInfo.documentDate}</DocDate>\n`;
    content += '  </GeneralInfo>\n';
    content += '  <ObjectInfo>\n';
    content += `    <ObjectName>${data.generalInfo.projectName}</ObjectName>\n`;
    content += `    <ObjectType>${data.objectInfo.objectType}</ObjectType>\n`;
    content += '  </ObjectInfo>\n';
    content += '  <Participants>\n';
    content += '    <Contractor>\n';
    content += `      <OrganizationName>${data.contractor.name}</OrganizationName>\n`;
    content += '    </Contractor>\n';
    content += '    <Designer>\n';
    content += `      <OrganizationName>${data.designer.name}</OrganizationName>\n`;
    content += '    </Designer>\n';
    content += '  </Participants>\n';

    return `${xmlHeader}\n${rootStart}\n${content}${rootEnd}`;
  }
}

// ============================================================================
// MAIN TEST RUNNER
// ============================================================================

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘   XML EDITOR DESKTOP - AUTOMATED TEST SUITE               â•‘');
  console.log('â•‘   Version 1.0.0                                            â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log('');
  console.log(`Start time: ${new Date().toISOString()}`);

  const tracker = new TestTracker();
  const db = new DatabaseHelper(CONFIG.DB_PATH);

  try {
    // Run all test suites
    const dbTests = new DatabaseTests(tracker, db);
    await dbTests.runAll();

    const schemaTests = new SchemaTests(tracker);
    await schemaTests.runAll();

    const crudTests = new CRUDTests(tracker, db);
    await crudTests.runAll();
    await crudTests.cleanup();

    const xmlTests = new XMLGenerationTests(tracker);
    await xmlTests.runAll();

    // Generate reports
    tracker.printConsoleReport();

    const report = tracker.generateReport();
    await fs.writeFile(CONFIG.TEST_OUTPUT, report, 'utf8');
    console.log(`ðŸ“„ Detailed report saved to: ${CONFIG.TEST_OUTPUT}\n`);

    // Exit with appropriate code
    const stats = tracker.getStats();
    process.exit(stats.failed > 0 ? 1 : 0);

  } catch (error) {
    console.error('\nâŒ FATAL ERROR:', error.message);
    console.error(error.stack);
    process.exit(1);
  } finally {
    await db.close();
  }
}

// Run tests
if (require.main === module) {
  main().catch(error => {
    console.error('Unhandled error:', error);
    process.exit(1);
  });
}

module.exports = { TestTracker, DatabaseHelper, TestSuite };
